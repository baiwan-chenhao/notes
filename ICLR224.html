<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>ICLR224</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="attenting">0. Attenting</h1>
<p>Retroformer: Retrospective Large Language Agents with Policy Gradient Optimization【agent自我优化】</p>
<p>In-context Autoencoder for Context Compression in a Large Language Model【上下文压缩内存槽，像组件标准化】</p>
<p>Making LLaMA SEE and Draw with SEED Tokenizer【mixer】</p>
<p>Chain-of-Knowledge: Grounding Large Language Models via Dynamic Knowledge Adapting over Heterogeneous Sources【rewrite】</p>
<p>Knowledge Fusion of Large Language Models【好新啊】</p>
<p>MEND: Meta Demonstration Distillation for Efficient and Effective In-Context Learning【rewriter很像】</p>
<p>Successor Heads: Recurring, Interpretable Attention Heads In The Wild【没见过这个东西，看看是什么再分类】</p>
<h1 id="deep-learning">1. Deep Learning</h1>
<h2 id="large-language-model">1.1. Large Language Model</h2>
<h3 id="masked-language-model">1.1.1. Masked Language Model</h3>
<p>Representation Deficiency in Masked Language Modeling</p>
<h3 id="decoding">1.1.2. Decoding</h3>
<p>The Consensus Game: Language Model Generation via Equilibrium Search</p>
<h3 id="sft">1.1.3. SFT</h3>
<p>OpenChat: Advancing Open-source Language Models with Mixed-Quality Data</p>
<p>CPPO: Continual Learning for Reinforcement Learning with Human Feedback</p>
<blockquote>
<p>从人类反馈中强化学习 （RLHF） 的方法广泛用于增强预训练语言模型 （LM），使它们能够更好地与人类偏好保持一致。然而，每当引入新的查询或反馈时，现有的基于 RLHF 的 LM 都需要完全重新训练，因为人类的偏好可能因不同的领域或主题而异。在大多数实际场景中，LM 再训练通常是不切实际的，因为涉及大量的时间和计算成本，以及数据隐私问题。为了解决这一限制，我们提出了持续近端策略优化 （CPPO），这是一种能够持续使 LM 与动态人类偏好保持一致的新方法。具体来说，CPPO 采用加权策略来决定哪些样本应该用于加强政策学习，哪些样本应该用于巩固过去的经验。这寻求在策略学习和知识保留之间进行良好的权衡。我们的实验结果表明，在始终如一地与人类偏好保持一致方面，CPPO 的表现优于强大的持续学习 （CL） 基线。此外，与 PPO 相比，CPPO 在非连续场景中提供了更高效、更稳定的学习。</p>
</blockquote>
<h3 id="multimodel-learing">1.1.4. Multimodel learing</h3>
<p>Large Multilingual Models Pivot Zero-Shot Multimodal Learning across Languages</p>
<p>Making LLaMA SEE and Draw with SEED Tokenizer</p>
<blockquote>
<p>训练了一个新的tokenizer和llm，使其同时可以理解和生成。</p>
</blockquote>
<p>MiniGPT-4: Enhancing Vision-Language Understanding with Advanced Large Language Models</p>
<blockquote>
<p>最近的 GPT-4 展示了非凡的多模态能力，例如直接从手写文本生成网站和识别图像中的幽默元素。这些特征在以前的视觉语言模型中很少观察到。但是，GPT-4 背后的技术细节仍未披露。我们相信，GPT-4 增强的多模态生成能力源于对复杂大型语言模型 （LLM） 的利用。为了研究这种现象，我们提出了 MiniGPT-4，它使用一个投影层将冻结的视觉编码器与冻结的高级 LLM Vicuna 对齐。我们的工作首次发现，将视觉特征与高级大型语言模型正确对齐可以拥有 GPT-4 演示的许多高级多模态能力，例如生成详细的图像描述和从手绘草稿创建网站。此外，我们还观察到 MiniGPT-4 中的其他新兴功能，包括受给定图像启发编写故事和诗歌、教用户如何根据食物照片烹饪等等。在我们的实验中，我们发现在短图像标题对上训练的模型可能会产生不自然的语言输出（例如，重复和碎片化）。为了解决这个问题，我们在第二阶段策划了一个详细的图像描述数据集来微调模型，从而提高模型的生成可靠性和整体可用性。</p>
</blockquote>
<h3 id="agent">1.1.5. Agent</h3>
<p>Retroformer: Retrospective Large Language Agents with Policy Gradient Optimization</p>
<blockquote>
<p>最近几个月出现了一个强大的新趋势，其中大型语言模型 （LLM） 被增强为自主语言代理，能够自行执行面向目标的多步骤任务，而不仅仅是响应人类用户的查询。但是，大多数现有的语言代理并未使用特定于环境的奖励进行优化。尽管一些代理通过口头反馈实现迭代优化，但它们的推理和计划方式与基于梯度的奖励学习兼容。本文介绍了一个原则性框架，通过学习回顾模型来加强大型语言代理，该模型通过策略梯度从环境反馈中自动调整语言代理提示。具体来说，我们提出的代理架构从多个环境和任务的奖励中学习，以微调预先训练的语言模型，该模型通过总结先前尝试失败的根本原因并提出行动计划来改进语言代理提示。各种任务的实验结果表明，语言代理会随着时间的推移而改进，并且我们的方法大大优于没有正确利用环境梯度的基线。</p>
</blockquote>
<p>CRITIC: Large Language Models Can Self-Correct with Tool-Interactive Critiquing</p>
<blockquote>
<p>大型语言模型 （LLM） 的最新发展令人印象深刻。但是，这些模型有时会显示不一致和有问题的行为，例如产生幻觉事实、生成有缺陷的代码或创建冒犯性和有害内容。与这些模型不同，人类通常利用外部工具来交叉检查和优化其初始内容，例如使用搜索引擎进行事实核查，或使用代码解释器进行调试。受这一观察的启发，我们引入了一个名为 CRITIC 的框架，它允许本质上是“黑匣子”的 LLM 以类似于人类与工具交互的方式验证和逐步修改自己的输出。更具体地说，从初始输出开始，CRITIC 与适当的工具交互以评估文本的某些方面，然后根据在此验证过程中获得的反馈修改输出。涉及自由形式问答、数学程序综合和降低毒性的综合评估表明，CRITIC 始终如一地提高 LLM 的性能。同时，我们的研究强调了外部反馈在促进 LLM 的持续自我提升中至关重要。</p>
</blockquote>
<p>MetaTool Benchmark for Large Language Models: Deciding Whether to Use Tools and Which to Use</p>
<blockquote>
<p>大型语言模型 （LLM） 因其令人印象深刻的自然语言处理 （NLP） 功能而引起了广泛关注。近年来，许多研究都集中在 LLM 的工具利用能力上。他们主要研究了 LLM 如何有效地与给定的特定工具协作。然而，在 LLM 充当智能代理的情况下，如 AutoGPT 和 MetaGPT 等应用程序所示，预计 LLM 将参与复杂的决策过程，包括决定是否使用工具以及从一系列可用工具中选择最合适的工具来满足用户请求。因此，在本文中，我们介绍了 MetaTool，这是一个旨在评估 LLM 是否具有工具使用意识并能正确选择工具的基准。具体来说，我们在基准测试中创建一个名为 ToolE 的数据集。此数据集包含各种类型的用户查询，这些查询以提示的形式触发 LLM 使用工具，包括单工具和多工具场景。随后，我们设置了工具使用意识和工具选择的任务。我们在工具选择中从不同的角度定义了四个子任务，包括选择相似的工具、特定场景下的工具选择、可能存在可靠性问题的工具选择和多工具选择。我们进行了涉及 8 个流行的 LLM 的实验，发现它们中的大多数仍然难以有效地选择工具，突出了 LLM 和真正的智能代理之间存在的差距。但是，通过错误分析，我们发现仍有很大的改进空间。最后，我们总结了对工具开发人员的见解 —— 我们强烈建议工具开发人员选择合适的重写模型，以根据工具将应用于的下游 LLM 生成新的描述。</p>
</blockquote>
<p>Evaluating Language Model Agency Through Negotiations</p>
<blockquote>
<p>我们介绍了一种使用谈判游戏评估语言模型 （LM） 代理的方法。这种方法更好地反映了实际用例，并解决了替代 LM 基准测试的一些缺点。谈判博弈使我们能够研究多轮次和跨模型交互，调节复杂性，并避免意外评估数据泄漏。我们使用我们的方法测试了六个广泛使用且可公开访问的 LM，评估自对弈和交叉对弈设置中的性能和对齐情况。值得注意的发现包括：（i） 只有此处测试的闭源模型能够完成这些任务;（ii） 合作讨价还价博弈被证明对模型最具挑战性;（iii） 即使是最强大的模型有时也会“输给”较弱的对手。</p>
</blockquote>
<h3 id="pruning">1.1.6. Pruning</h3>
<p>BESA: Pruning Large Language Models with Blockwise Parameter-Efficient Sparsity</p>
<blockquote>
<p>大型语言模型 （LLM） 在各种任务中表现出出色的性能，例如文本摘要、文本问答等。虽然它们的性能令人印象深刻，但由于参数数量众多，计算占用空间可能令人望而却步。现有的解决方案，如 SparseGPT 和 Wanda，试图通过权重修剪来缓解这个问题。然而，他们的分层方法会导致对模型输出的显著扰动，并且需要细致的超参数调整，例如修剪率，这可能会对模型的整体性能产生不利影响。为了解决这个问题，本文介绍了一种新颖的 LLM 修剪技术，称为块参数高效稀疏分配 （BESA），它通过应用块重建损失。与典型的逐层修剪技术相比，BESA 具有两个独特的属性：i） 它针对单个变压器块的整体修剪误差，以及 ii） 它以可微分的方式分配特定于层的稀疏性，这两者都确保减少修剪后的性能下降。我们的实验表明， BESA 实现了最先进的性能，可在短短 5 小时内在单个 A100 GPU 上高效修剪具有 7B 到 70B 参数的 LLaMA1 和 LLaMA2 等 LLM。代码可在 <a href="https://github.com/LinkAnonymous/BESA">此处</a>.</p>
</blockquote>
<h3 id="text-generating">1.1.7. Text Generating</h3>
<p>Branch-GAN: Improving Text Generation with (not so) Large Language Models</p>
<blockquote>
<p>当前开放域文本生成的进步是由基于 Transformer 的大型语言模型引领的。利用高效的并行化和庞大的训练数据集，这些模型实现了无与伦比的文本生成功能。即便如此，众所周知，当前的模型存在诸如重复文本、循环问题和缺乏稳健性等缺陷。虽然通过生成对抗网络 （GAN） 进行对抗性训练是一个拟议的解决方案，但该方向的早期研究主要集中在较旧的架构或狭窄的任务上。因此，这种方法尚不兼容用于开放式文本生成的现代语言模型，导致更广泛的研究社区的兴趣减弱。我们提出了一种计算高效的顺序数据 GAN 方法，该方法利用 Transformer 模型的并行化功能。我们的方法围绕着从每个训练样本生成多个分支序列，同时还在原始数据上纳入典型的下一步预测损失。通过这种方式，我们为生成器和判别器都实现了密集的奖励和损失信号，从而产生了稳定的训练动态。我们将训练方法应用于预先训练的语言模型，使用来自原始训练集的数据，但不到可用数据的 0.01%。全面的人工评估表明，我们的方法显著提高了模型生成的文本质量，同时避免了以前报道的 GAN 方法的稀疏性问题。即使是我们较小的模型也优于较大的原始基线模型，其参数数量是其 16 倍以上。最后，我们证实了之前的说法，即对保留数据的困惑并不是衡量生成文本质量的足够指标。</p>
</blockquote>
<h3 id="rag">1.1.8. RAG</h3>
<p>RAPTOR: Recursive Abstractive Processing for Tree-Organized Retrieval</p>
<blockquote>
<p>检索增强语言模型可以更好地适应世界状态的变化并整合长尾知识。然而，大多数现有方法仅从检索语料库中检索短的连续块，从而限制了对整个文档上下文的整体理解。我们引入了递归嵌入、聚类和总结文本块的新方法，自下而上构建了一个具有不同摘要级别的树。在推理时，我们的 RAPTOR 模型从这棵树中检索，在不同抽象层次上集成冗长文档中的信息。对照实验表明，在多项任务上，与传统的检索增强 LM 相比，使用递归摘要进行检索的检索提供了显著改进。在涉及复杂、多步骤推理的问答任务中，我们展示了最先进的结果;例如，通过将 RAPTOR 检索与 GPT-4 的使用相结合，我们可以将 QuALITY 基准测试的最佳性能提高 20% 的绝对准确率。</p>
</blockquote>
<p>Chain-of-Knowledge: Grounding Large Language Models via Dynamic Knowledge Adapting over Heterogeneous Sources</p>
<blockquote>
<p>我们提出了知识链 （CoK），这是一种新颖的框架，通过动态整合来自异构来源的基础信息来增强大型语言模型 （LLM）。它导致更多的事实理由并减少世代的幻觉。具体来说，CoK 包括三个阶段：推理准备、动态知识适应和答案巩固。给定一个知识密集型问题，CoK 首先准备几个初步的基本原理和答案，同时确定相关的知识领域。如果样本的答案之间没有多数共识，CoK 会通过调整已识别领域的知识来逐步纠正基本原理。这些更正后的理由可以合理地作为最终答案合并的更好基础。与之前主要使用非结构化数据的研究不同，CoK 还利用了结构化知识来源，例如 Wikidata 和表格，这些资源提供了更可靠的事实信息。为了在动态知识适应阶段访问非结构化和结构化的知识源，我们提出了一个自适应查询生成器，允许为各种类型的查询语言生成查询，包括 SPARQL、SQL 和自然句。此外，为了最大限度地减少基本原理之间的错误传播，CoK 使用先前更正的基本原理逐步纠正基本原理，以生成和纠正后续的基本原理。广泛的实验表明，CoK 始终如一地提高了 LLM 在不同领域的知识密集型任务上的性能。</p>
</blockquote>
<h3 id="postion-encode-extension">1.1.9. Postion Encode Extension</h3>
<p>YaRN: Efficient Context Window Extension of Large Language Models</p>
<blockquote>
<p>旋转位置嵌入 （RoPE） 已被证明可以在基于 transformer 的语言模型中有效地编码位置信息。然而，这些模型无法推广到它们所训练的序列长度之后。我们提出了 YaRN （Yet another RoPE extensioN method），这是一种扩展此类模型的上下文窗口的计算高效方法，与以前的方法相比，需要的令牌减少了 10 倍，训练步骤减少了 2.5 倍。使用 YaRN，我们表明 LLaMA 模型可以有效地利用和推断比其原始预训练允许的更长的上下文长度，同时也超越了以前最先进的上下文窗口扩展。此外，我们还证明了 YaRN 表现出在微调数据集的有限上下文之外进行推断的能力。使用 YaRN 微调的模型已在线提供和复制，上下文长度可达 128k。</p>
</blockquote>
<p>PoSE: Efficient Context Window Extension of LLMs via Positional Skip-wise Training</p>
<blockquote>
<p>大型语言模型 （LLM） 使用预定义的上下文长度进行训练，从而限制了它们在需要长输入的场景中的使用。以前将 LLM 调整为更长长度的努力通常需要对这个目标长度进行微调（全长微调），这需要大量的训练成本。为了将训练长度与目标长度解耦以实现高效的上下文窗口扩展，我们提出了位置跳跃式 （PoSE） 训练，它使用固定的上下文窗口智能地模拟长输入。这是通过首先将原始上下文窗口划分为几个块，然后设计不同的跳过偏差项来操纵每个块的位置索引来实现的。对于每个训练样本，这些偏差项和每个块的长度都会发生变化，从而使模型能够适应目标长度内的所有位置。实验结果表明，与 Full-length fine-tuning 相比，PoSE 大大减少了内存和时间开销，对性能的影响最小。利用这一优势，我们成功地使用 2k 训练上下文窗口将 LLaMA 模型扩展到 128k 令牌。此外，我们实证证实 PoSE 与所有基于 RoPE 的 LLM 和位置插值策略兼容。值得注意的是，我们的方法可能支持无限长度，仅受推理中的内存使用量限制。随着高效推理的不断进步，我们相信 PoSE 可以进一步将上下文窗口扩展到 128k 以上。</p>
</blockquote>
<h3 id="context-compression">1.1.10. Context Compression</h3>
<p>In-context Autoencoder for Context Compression in a Large Language Model</p>
<blockquote>
<p>我们提出了上下文自动编码器 （ICAE），利用大型语言模型 （LLM） 的强大功能将长上下文压缩为简短的紧凑内存插槽，这些内存插槽可以直接由 LLM 用于各种目的。ICAE 首先使用自动编码和语言建模目标对大量文本数据进行预训练，使其能够生成准确、全面地表示原始上下文的内存槽。然后，它对指令数据进行微调，以对各种提示产生理想的响应。实验表明，我们的轻量级 ICAE 引入了约 1% 的额外参数，有效地实现了4×4×基于 Llama 的上下文压缩，在推理过程中提供改进的延迟和 GPU 内存成本方面的优势，并在记忆和可扩展性方面显示出有趣的见解。这些有希望的结果意味着对认知科学中的工作记忆与 LLM 中的表征学习之间的联系提出了一种新的视角，揭示了 ICAE 在解决长期上下文问题方面的重要意义，并建议对 LLM 上下文管理进行进一步研究。我们的数据、代码和模型可在 https://github.com/getao/icae 获得。</p>
</blockquote>
<h3 id="benchmark">1.1.11. Benchmark</h3>
<p>Evaluating the Zero-shot Robustness of Instruction-tuned Language Models</p>
<blockquote>
<p>指令微调最近成为一种很有前途的方法，可以提高大型语言模型 （LLM） 在新任务上的零样本能力。这项技术在提高中等大小的 LLM 的性能方面显示出特别的优势，有时会引起与更大的模型变体竞争的性能。在本文中，我们提出了两个问题：（1） 指令调整模型对指令的特定措辞有多敏感，以及 （2） 我们如何使它们对这种自然语言变化更健壮？为了回答前者，我们收集了一组由 NLP 从业者手动编写的 319 条指令，这些指令包含在广泛使用的基准测试中，用于 80 多项独特任务，并与在教学微调期间观察到的指令措辞相比，我们评估了这些指令的方差和平均性能。我们发现，使用新颖的（未观察到的）但适当的指令短语始终会降低模型性能，有时甚至会大大降低。此外，尽管它们在语义上等效，但这种自然指令在下游性能上会产生很大的差异。换句话说，指令调整模型对指令改写并不是特别健壮。我们提出了一种简单的方法来缓解这个问题，方法是引入soft prompt’’ 嵌入参数并优化这些参数，以最大限度地提高语义等效指令的表示之间的相似性。我们表明，这种方法始终如一地提高了指令调整模型的鲁棒性。</p>
</blockquote>
<p>Evaluating Language Model Agency Through Negotiations</p>
<blockquote>
<p>我们介绍了一种使用谈判游戏评估语言模型 （LM） 代理的方法。这种方法更好地反映了实际用例，并解决了替代 LM 基准测试的一些缺点。谈判博弈使我们能够研究多轮次和跨模型交互，调节复杂性，并避免意外评估数据泄漏。我们使用我们的方法测试了六个广泛使用且可公开访问的 LM，评估自对弈和交叉对弈设置中的性能和对齐情况。值得注意的发现包括：（i） 只有此处测试的闭源模型能够完成这些任务;（ii） 合作讨价还价博弈被证明对模型最具挑战性;（iii） 即使是最强大的模型有时也会“输给”较弱的对手。</p>
</blockquote>
<p>Compressing LLMs: The Truth is Rarely Pure and Never Simple</p>
<blockquote>
<p>尽管现代大型语言模型 （LLM） 取得了非凡的成就，但它们仍面临着巨大的计算和内存占用。最近，几项工作在对 LLM 的 <em>无训练</em> 和 <em>无数据</em> 压缩（修剪和量化）方面取得了重大成功，实现了 50-60% 的稀疏性，并将位宽降低到每个权重 3 或 4 位，在未压缩的基线上，困惑度下降可以忽略不计。由于最近的研究工作集中在开发越来越复杂的压缩方法上，我们的工作后退了一步，重新评估了现有 SoTA 压缩方法的有效性，这些方法依赖于一个相当简单且广受质疑的指标，即困惑度（即使对于密集的 LLM）。我们推出了 <strong>K</strong>nowledge-<strong>I</strong>ntensive <strong>C</strong>ompressed LLM Benchmar<strong>K</strong> <strong>（LLM-KICK）</strong>，这是一组精心策划的任务，用于重新定义压缩 LLM 的评估协议，这些协议与密集的对应物具有显著的一致性，并且困惑无法捕捉到其真实能力的细微变化。LLM-KICK 揭示了当前 SoTA 压缩方法的许多有利优点和不幸的困境：所有修剪方法都遭受了显着的性能下降，有时在微不足道的稀疏率（<em>例如</em>，25-30%）下，并且在知识密集型任务上失败了 N：M 稀疏性;当前的量化方法比修剪更成功;然而，修剪后的 LLM 即使在≥50≥50% sparsity 是健壮的上下文检索和摘要系统;等等。LLM-KICK 旨在全面访问压缩的 LLM 的语言理解、推理、生成、上下文检索、上下文摘要等能力。我们希望我们的研究可以促进更好的 LLM 压缩方法的发展。复制的代码可在 https://github.com/VITA-Group/llm-kick 上获得。</p>
</blockquote>
<h3 id="推荐系统">1.1.12. 推荐系统</h3>
<p>Large Content And Behavior Models To Understand, Simulate, And Optimize Content And Behavior</p>
<blockquote>
<p>Shannon 和 Weaver 的开创性信息理论将通信分为三个层次：技术、语义和有效性。技术层面处理传输符号的准确重建，而语义和有效性层面处理推断的含义及其对接收者的影响。大型语言模型 （LLM） 具有广泛的泛化性，在第二级方面取得了一些进展。但是，LLM 和其他通信模型通常不是为预测和优化所需的接收者行为和意图的通信而设计的。因此，现代通信系统在很大程度上不会影响其有效性水平。在本文中，我们在 LLM 的训练语料库中引入了接收者的“行为代币”，例如分享、点赞、点击、购买和转发，以便为接收者优化内容并预测他们的行为。除了在内容理解任务上表现出与 LLM 相似的性能外，我们经过训练的模型还显示了行为模拟、内容模拟、行为理解和行为域适应的行为维度的泛化能力。我们在三个语料库中使用广泛的任务来展示所有这些功能的结果。我们将这些模型称为大内容和行为模型 （LCBM）。此外，为了促进对 LCBM 的更多研究，我们发布了新的内容行为语料库 （CBC），这是一个包含通信器、消息和相应接收者行为 （https://behavior-in-the-wild.github.io/LCBM） 的存储库。</p>
</blockquote>
<h3 id="discover">1.1.13 Discover</h3>
<p>Language Modeling Is Compression</p>
<blockquote>
<p>人们早就确定，预测模型可以转换为无损压缩器，反之亦然。顺便说一句，近年来，机器学习社区专注于训练越来越大和强大的自我监督（语言）模型。由于这些大型语言模型表现出令人印象深刻的预测能力，因此它们非常适合成为强大的压缩器。在这项工作中，我们主张通过压缩的视角来看待预测问题，并评估大型（基础）模型的压缩能力。我们表明，大型语言模型是强大的通用预测器，压缩视点为缩放定律、分词化和上下文学习提供了新的见解。例如，Chinchilla 70B 虽然主要使用文本进行训练，但将 ImageNet 补丁压缩到原始大小的 43.4%，将 LibriSpeech 样本压缩到原始大小的 16.4%，分别击败了 PNG （58.5%） 或 FLAC （30.3%） 等特定领域的压缩器。最后，我们表明 prediction-compression 等价性允许我们使用任何压缩器（如 gzip）来构建条件生成模型。</p>
</blockquote>
<p>Linearity of Relation Decoding in Transformer Language Models</p>
<blockquote>
<p>Much of the knowledge encoded in transformer language models (LMs) may be expressed in terms of relations: relations between words and their synonyms, entities and their attributes, etc. We show that, for a subset of relations, this computation is well-approximated by a single linear transformation on the subject representation. Linear relation representations may be obtained by constructing a first-order approximation to the LM from a single prompt, and they exist for a variety of factual, commonsense, and linguistic relations. However, we also identify many cases in which LM predictions capture relational knowledge accurately, but this knowledge is not linearly encoded in their representations. Our results thus reveal a simple, interpretable, but heterogeneously deployed knowledge representation strategy in transformer LMs.</p>
</blockquote>
<p>The Expressive Power of Low-Rank Adaptation</p>
<h3 id="kowledge-editing">1.1.14. Kowledge Editing</h3>
<p>Unveiling the Pitfalls of Knowledge Editing for Large Language Models</p>
<blockquote>
<p>随着与微调大型语言模型 （LLM） 相关的成本不断上升，最近的研究工作已转向开发编辑嵌入在 LLM 中的隐式知识的方法。然而，头顶上仍有乌云萦绕——知识编辑会触发蝴蝶效应吗？因为目前尚不清楚知识编辑是否会引入带来潜在风险的副作用。本文率先调查了与 LLM 知识编辑相关的潜在陷阱。为了实现这一目标，我们引入了新的基准数据集并提出了创新的评估指标。我们的结果强调了两个关键问题：（1） 知识冲突：编辑逻辑冲突的事实组会放大 LLM 中固有的不一致——这是以前的方法所忽视的一个方面。（2） 知识扭曲：以编辑事实知识为目的而改变参数可以不可逆转地扭曲 LLM 的先天知识结构。实验结果生动地表明，知识编辑可能会无意中给 LLM 蒙上意想不到的后果的阴影，这需要关注和努力用于未来的工作。代码和数据可在 https://github.com/zjunlp/PitfallsKnowledgeEditing 获取。</p>
</blockquote>
<h3 id="inferencing">1.1.15. Inferencing</h3>
<p>Hybrid LLM: Cost-Efficient and Quality-Aware Query Routing</p>
<blockquote>
<p>大型语言模型 （LLM） 在大多数 NLP 任务中表现出色，但由于其规模的原因，还需要昂贵的云服务器进行部署，而可以部署在低成本（例如边缘）设备上的较小模型在响应质量方面往往落后。因此，在这项工作中，我们提出了一种混合推理方法，该方法结合了各自的优势，以节省成本并保持质量。我们的方法使用路由器，该路由器根据预测的查询难度和所需的质量级别将查询分配给小型或大型模型。可以在测试时动态调整所需的质量级别，以便根据场景要求无缝地以质量换取成本。在实验中，我们的方法允许我们将对大型模型的调用减少多达 40%，而响应质量没有下降。</p>
</blockquote>
<h3 id="new">1.1.16. NEW</h3>
<p>Knowledge Fusion of Large Language Models</p>
<blockquote>
<p>虽然从头开始训练大型语言模型 （LLM） 可以生成具有不同功能和优势的模型，但它需要付出巨大的成本，并可能导致冗余功能。或者，一种经济高效且引人注目的方法是将现有的预训练 LLM 合并到更有效的模型中。但是，由于这些 LLM 的架构不同，直接混合它们的权重是不切实际的。在本文中，我们介绍了 LLM 的知识融合概念，旨在结合现有 LLM 的功能并将它们转移到单个 LLM 中。通过利用源 LLM 的生成分布，我们将他们的集体知识和独特优势外化，从而有可能将目标模型的能力提升到超越任何单个源 LLM 的能力。我们在各种基准测试和任务中使用三种具有不同架构的流行 LLM（Llama-2、MPT 和 OpenLLaMA）来验证我们的方法。我们的研究结果证实，LLM 的融合可以提高目标模型在推理、常识和代码生成等一系列功能方面的性能。我们的代码、模型权重和数据在  中公开。</p>
</blockquote>
<h3 id="distillation">1.1.17. Distillation</h3>
<p>MEND: Meta Demonstration Distillation for Efficient and Effective In-Context Learning</p>
<blockquote>
<p>大型语言模型 （LLM） 已经展示了令人印象深刻的上下文学习 （ICL） 功能，其中 LLM 对给定的测试输入以及一些输入-输出对（演示）进行预测。然而，包含演示带来了挑战，导致自我注意机制的计算开销呈二次方增加。现有解决方案试图将冗长的演示压缩为紧凑的向量。但是，它们通常需要针对特定任务的再训练，否则会损害 LLM 的上下文学习性能。为了缓解这些挑战，我们提出了 Meta Demonstration Distillation （MEND），其中语言模型学习将任何冗长的演示提取到向量中，而无需重新训练新的下游任务。我们利用知识蒸馏来增强 MEND 和 MEND 之间的一致性，同时实现效率和有效性。MEND 通过两阶段培训过程（包括元蒸馏预训练和微调）获得了蒸馏演示的元知识。使用仅解码器 （GPT-2） 和编码器-解码器 （T5） 对七种不同的 ICL 设置进行全面评估，证明了 MEND 的实力。它不仅与 Vanilla ICL 以及其他最先进的蒸馏模型相匹配，而且经常优于 Vanilla ICL 以及其他最先进的蒸馏模型，同时显著降低了计算需求。这项创新有望为大型语言模型的实际部署提供增强的可扩展性和效率。</p>
</blockquote>
<h3 id="knowledge-graph">1.1.18. Knowledge Graph</h3>
<p>Think-on-Graph: Deep and Responsible Reasoning of Large Language Model on Knowledge Graph</p>
<blockquote>
<p>尽管大型语言模型 （LLM） 在各种任务中取得了重大成功，但它们经常与幻觉问题作斗争，尤其是在需要深入和负责任的推理的情况下。这些问题可以通过在 LLM 推理中引入外部知识图谱 （KG） 来部分解决。在本文中，我们提出了一种新的 LLM-KG 集成范式法学硕士⊗病历法学硕士⊗病历“”，它将 LLM 视为代理，以交互方式探索 KG 上的相关实体和关系，并根据检索到的知识进行推理。我们通过引入一种称为 Think-on-Graph （ToG） 的新方法来进一步实现这一范式，其中 LLM 代理在 KG 上迭代执行光束搜索，发现最有希望的推理路径，并返回最可能的推理结果。我们使用许多精心设计的实验来检验和说明 ToG 的以下优势：1） 与 LLM 相比，ToG 具有更好的深度推理能力;2） ToG 通过利用 LLM 推理和专家反馈，具有知识可追溯性和知识可纠正性的能力;3） ToG 为不同的 LLM、KG 和提示策略提供了一个灵活的即插即用框架，无需任何额外的培训成本;4） 在某些情况下，小型 LLM 模型的 ToG 性能可能会超过大型 LLM，例如 GPT-4，这降低了 LLM 部署和应用的成本。作为一种计算成本更低、通用性更好的免训练方法，ToG 在 9 个数据集中的 6 个数据集中实现了整体 SOTA，而以前的大多数 SOTA 都依赖于额外的训练。</p>
</blockquote>
</body>
</html>
